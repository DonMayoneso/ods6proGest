<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>Viajando...</title>
<link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
<style>
  :root{ --bg:#040417; }
  html,body{ height:100%; margin:0; background:var(--bg); overflow:hidden; font-family:'VT323', monospace; color:#fff;}
  canvas{ display:block; }
  
  /* Efectos Retro */
  #retro {
    position:fixed; inset:0; pointer-events:none;
    background-image: linear-gradient(transparent 50%, rgba(0,0,0,0.06) 50%);
    background-size:100% 4px;
    mix-blend-mode:overlay; opacity:0.7; z-index: 10;
  }
  #vignette { 
    position:fixed; inset:0; pointer-events:none;
    background: radial-gradient(ellipse at center, rgba(0,0,0,0) 40%, rgba(0,0,0,0.55) 100%); 
    mix-blend-mode:multiply; opacity:0.9; z-index: 10;
  }

  /* BOTÓN SALTAR (SKIP) - DERECHA */
  .skip-btn {
    position: fixed; 
    bottom: 30px; 
    right: 30px;
    background: rgba(0, 20, 40, 0.7); 
    border: 1px solid #4fc3f7; 
    color: #4fc3f7;
    font-family: 'VT323', monospace; 
    font-size: 1.3rem; 
    padding: 10px 25px;
    cursor: pointer; 
    z-index: 100; 
    pointer-events: auto;
    transition: all 0.3s; 
    text-transform: uppercase;
    border-radius: 4px;
    backdrop-filter: blur(2px);
    letter-spacing: 2px;
  }
  
  .skip-btn:hover { 
    background: rgba(79, 195, 247, 0.2); 
    color: white; 
    box-shadow: 0 0 15px rgba(79, 195, 247, 0.4);
  }

  /* --- EASTER EGG (IZQUIERDA - MEJORADO) --- */
  #easter-egg {
      position: fixed;
      bottom: 0;      /* Pegado al borde inferior */
      left: 0;        /* Pegado al borde izquierdo */
      width: 150px;   /* Área de clic generosa */
      height: 150px;
      /* Totalmente invisible */
      opacity: 0; 
      background: red; /* Color de debug interno */
      z-index: 9999; /* Por encima de absolutamente todo */
      
      /* UX Stealth: Cursor normal */
      cursor: default; 
      
      display: block;
      text-decoration: none;
      -webkit-tap-highlight-color: transparent; /* Evita el flash azul en móviles */
  }

  /* RESPONSIVE */
  @media (max-width: 768px) {
    .skip-btn { 
        bottom: 20px; 
        right: 20px; 
        font-size: 1.1rem; 
        padding: 12px 20px; 
    }
    /* En móvil el easter egg puede ser un poco más pequeño para no estorbar */
    #easter-egg {
        width: 100px;
        height: 100px;
    }
  }
</style>
</head>
<body>
<div id="retro"></div>
<div id="vignette"></div>

<button id="skip-btn" class="skip-btn">[ SALTAR ]</button>

<a href="htmlmanager.html" id="easter-egg"></a>

<script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>

<script>

/* ========== CONFIGURACIÓN DINÁMICA ========== */
const urlParams = new URLSearchParams(window.location.search);
const currentWorldId = urlParams.get('mundo') || 'Mundo A'; 

let planetColor1 = '#2ca06c'; 
let planetColor2 = '#14703f'; 
const cloudAlpha = 0.08;
const speedMultiplier = 1.0;
const enableRetroOverlay = true;

/* ========== Setup básico THREE.JS ========== */
let renderer, scene, camera;
let width = window.innerWidth, height = window.innerHeight;
renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(width, height);
renderer.outputEncoding = THREE.sRGBEncoding;
document.body.appendChild(renderer.domElement);

scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x02040b, 0.00035);

camera = new THREE.PerspectiveCamera(60, width/height, 0.1, 5000);

// Función de ajuste de cámara responsive
function updateCamera() {
  width = window.innerWidth; height = window.innerHeight;
  camera.aspect = width/height; 
  camera.updateProjectionMatrix();
  renderer.setSize(width, height);

  if(width < 768) {
      camera.position.set(0, 10, 65); 
  } else {
      camera.position.set(0, 8, 48); 
  }
}
updateCamera();
window.addEventListener('resize', updateCamera);

document.getElementById('retro').style.opacity = enableRetroOverlay ? '0.7' : '0.0';
document.getElementById('vignette').style.opacity = enableRetroOverlay ? '0.9' : '0.0';

/* ---------- Luces ---------- */
const hemi = new THREE.HemisphereLight(0xb0d8ff, 0x202030, 0.9);
scene.add(hemi);
const dir = new THREE.DirectionalLight(0xffffff, 1.0);
dir.position.set(10, 20, 10);
scene.add(dir);

/* ---------- Paleta y util ---------- */
const PALETTE = { shipBody:0xdfe9f3, shipAccent:0x08324a, nozzle:0xffcc66 };
function lerp(a,b,t){ return a + (b-a) * t; }
function easeInOutQuad(t){ return t<0.5 ? 2*t*t : -1 + (4-2*t)*t; }
function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }

/* ---------- Starfield ---------- */
function makeStarfield(count, radius){
  const geo = new THREE.BufferGeometry();
  const positions = new Float32Array(count*3);
  const colors = new Float32Array(count*3);
  for(let i=0;i<count;i++){
    const phi = Math.acos(2*Math.random()-1);
    const theta = 2*Math.PI*Math.random();
    const r = radius * (0.25 + Math.random()*0.75);
    const x = Math.sin(phi) * Math.cos(theta) * r;
    const y = Math.sin(phi) * Math.sin(theta) * r/1.4;
    const z = Math.cos(phi) * r;
    positions[i*3]=x; positions[i*3+1]=y; positions[i*3+2]=z;
    const c = (Math.random() > 0.98) ? 1.0 : 0.78;
    colors[i*3]=c; colors[i*3+1]=c; colors[i*3+2]=c;
  }
  geo.setAttribute('position', new THREE.BufferAttribute(positions,3));
  geo.setAttribute('color', new THREE.BufferAttribute(colors,3));
  const mat = new THREE.PointsMaterial({ size:1.9, sizeAttenuation:true, vertexColors:true, transparent:true, opacity:0.95, depthWrite:false});
  return new THREE.Points(geo, mat);
}
const starfield = makeStarfield(1600, 2400);
scene.add(starfield);

/* ---------- Planeta (textura generada) ---------- */
const planetRadius = 340;
const planetGeo = new THREE.SphereGeometry(planetRadius, 64, 40);
let planet; 

function makePlanetTextureFromStyle(c1, c2, cAlpha, size=2048){
  const c = document.createElement('canvas');
  c.width = c.height = size;
  const ctx = c.getContext('2d');
  const g = ctx.createLinearGradient(0,0,size,size);
  g.addColorStop(0, c1); g.addColorStop(1, c2);
  ctx.fillStyle = g; ctx.fillRect(0,0,size,size);
  ctx.globalAlpha = 0.14; ctx.strokeStyle = 'rgba(255,255,255,0.08)';
  for(let i=0;i<32;i++){
    const y = size * (i/32) + Math.sin(i*0.7) * (10 + Math.sin(i)*4);
    ctx.lineWidth = 8 * (0.6 + Math.random()*0.9);
    ctx.beginPath(); ctx.ellipse(size/2, y, size*0.48, size*0.06 + Math.random()*16, Math.random()*0.4, 0, Math.PI*2); ctx.stroke();
  }
  ctx.globalAlpha = cAlpha; ctx.fillStyle = '#ffffff';
  for(let i=0;i<80;i++){
    const rx = Math.random()*size; const ry = Math.random()*size;
    const rw = size*0.25*(0.25+Math.random()); const rh = size*0.06*(0.5+Math.random());
    ctx.beginPath(); ctx.ellipse(rx, ry, rw, rh, Math.random()*Math.PI, 0, Math.PI*2); ctx.fill();
  }
  return new THREE.CanvasTexture(c);
}

/* ---------- Nave Futurista ---------- */
function makeShipFuturistic() {
  const g = new THREE.Group();
  const matHull = new THREE.MeshStandardMaterial({ color: 0xddeeff, metalness: 0.6, roughness: 0.3 });
  const matMech = new THREE.MeshStandardMaterial({ color: 0x4a6b8c, metalness: 0.7, roughness: 0.4 });
  const matCockpit = new THREE.MeshStandardMaterial({ color: 0x223344, metalness: 0.9, roughness: 0.1 });
  const matGlow = new THREE.MeshStandardMaterial({ color: 0xffaa00, emissive: 0xff5500, emissiveIntensity: 5, toneMapped: false });

  const bodyGeo = new THREE.ConeGeometry(0.8, 5, 8); bodyGeo.rotateX(Math.PI / 2);
  const body = new THREE.Mesh(bodyGeo, matHull); body.scale.set(1, 1, 1.2); g.add(body);
  const cockGeo = new THREE.BoxGeometry(0.9, 0.4, 2); const cockpit = new THREE.Mesh(cockGeo, matCockpit);
  cockpit.position.set(0, 0.5, 0.5); cockpit.scale.set(1, 1, 0.8); g.add(cockpit);

  function createEngine(xPos) {
    const engGroup = new THREE.Group();
    const eng = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.8, 2.5), matMech);
    eng.position.set(0, 0, 1); engGroup.add(eng);
    const burner = new THREE.Mesh(new THREE.PlaneGeometry(0.7, 0.7), matGlow);
    burner.position.set(0, 0, 2.26); burner.rotation.y = Math.PI; engGroup.add(burner);
    engGroup.position.set(xPos, 0, 0); return engGroup;
  }
  g.add(createEngine(-1.6), createEngine(1.6));

  const wingL = new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.1, 3), matHull);
  wingL.position.set(-2.2, 0, 1); wingL.rotation.y = -0.3; wingL.rotation.z = 0.1;
  const wingR = new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.1, 3), matHull);
  wingR.position.set(2.2, 0, 1); wingR.rotation.y = 0.3; wingR.rotation.z = -0.1;
  g.add(wingL, wingR);

  const tailL = new THREE.Mesh(new THREE.BoxGeometry(0.2, 1.5, 2), matMech);
  tailL.position.set(-1.6, 0.8, 2); tailL.rotation.z = 0.3;
  const tailR = new THREE.Mesh(new THREE.BoxGeometry(0.2, 1.5, 2), matMech);
  tailR.position.set(1.6, 0.8, 2); tailR.rotation.z = -0.3;
  g.add(tailL, tailR);

  const laserGeo = new THREE.CylinderGeometry(0.05, 0.05, 3); laserGeo.rotateX(Math.PI / 2);
  const laserL = new THREE.Mesh(laserGeo, matGlow); laserL.position.set(-2.8, -0.1, 0);
  const laserR = laserL.clone(); laserR.position.set(2.8, -0.1, 0);
  g.add(laserL, laserR);

  g.scale.set(3.5, 3.5, 3.5); g.userData.center = new THREE.Vector3(0, 0, 0); return g;
}

const ship = makeShipFuturistic();
ship.position.set(0, -6, 10);
scene.add(ship);

/* ---------- Exhaust particles ---------- */
const exhaustCount = 500;
const exGeo = new THREE.BufferGeometry();
const exPos = new Float32Array(exhaustCount*3);
const exLife = new Float32Array(exhaustCount);
for(let i=0;i<exhaustCount;i++){ exPos[i*3]=10000; exLife[i]=0; }
exGeo.setAttribute('position', new THREE.BufferAttribute(exPos,3));
exGeo.setAttribute('aLife', new THREE.BufferAttribute(exLife,1));
const exMat = new THREE.PointsMaterial({ color:PALETTE.nozzle, size:1.9, transparent:true, opacity:0.95, depthWrite:false });
const exhaust = new THREE.Points(exGeo, exMat);
scene.add(exhaust);
const exVel = new Array(exhaustCount).fill(0).map(()=>({x:0,y:0,z:0}));
const exAge = new Float32Array(exhaustCount);

function emitExhaust(worldX, worldY, worldZ, power){
  for(let i=0;i<exhaustCount;i++){
    if(exLife[i] <= 0){
      const jitter = 0.7;
      exPos[i*3] = worldX + (Math.random()-0.5)*jitter;
      exPos[i*3+1] = worldY + (Math.random()-0.5)*jitter;
      exPos[i*3+2] = worldZ + (Math.random()-0.5)*jitter;
      exLife[i] = 0.6 + Math.random()*1.0 * power;
      break;
    }
  }
}

/* ---------- Inicialización y Lógica Salto ---------- */
renderer.toneMappingExposure = 1.0;
let t = 0;
let state = 'idle';
let last = performance.now();
let animationComplete = false;
const SEQ = { prelaunch:900, ignition:700, liftoff:3000, cruise:7000 };

// Lógica de Salto
const skipBtn = document.getElementById('skip-btn');
skipBtn.addEventListener('click', () => {
    if (animationComplete) return;
    skipBtn.style.pointerEvents = 'none';
    skipBtn.innerHTML = 'SALTANDO...';
    animationComplete = true;
    triggerTransition(1000); 
});

function triggerTransition(delay = 2500) {
    const transitionOverlay = document.createElement('div');
    transitionOverlay.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:#000;opacity:0;transition:opacity 1s;z-index:10000';
    document.body.appendChild(transitionOverlay);
    setTimeout(() => { transitionOverlay.style.opacity = '1'; }, 50);
    setTimeout(() => {
        window.location.href = 'mundo.html?mundo=' + encodeURIComponent(currentWorldId);
    }, delay);
}

// Inicio
async function startExperience() {
    try {
        const response = await fetch('datos.json');
        const data = await response.json();
        const world = data.mundos.find(w => w.id === currentWorldId);
        if (world && world.color1 && world.color2) {
            planetColor1 = world.color1; planetColor2 = world.color2;
        }
    } catch (e) { console.error(e); }

    const planetMat = new THREE.MeshStandardMaterial({
        map: makePlanetTextureFromStyle(planetColor1, planetColor2, cloudAlpha, 2048),
        metalness: 0.02, roughness: 0.86, emissive: 0x001f12, emissiveIntensity: 0.05
    });
    planet = new THREE.Mesh(planetGeo, planetMat);
    planet.position.set(0, -12, -800);
    scene.add(planet);
    requestAnimationFrame(animate);
}
startExperience();

/* ---------- Loop de Animación ---------- */
function animate(now){
  if (animationComplete && skipBtn.innerHTML === 'SALTANDO...') {} 

  const rawDt = Math.min(40, now - last); last = now;
  const dt = rawDt * 0.001 * speedMultiplier;
  t += dt;

  if(state==='idle' && t > 0.6) { state='prelaunch'; }
  if(state==='prelaunch' && t > 0.6 + SEQ.prelaunch/1000) { state='ignition'; }
  if(state==='ignition' && t > 0.6 + (SEQ.prelaunch+SEQ.ignition)/1000) { state='liftoff'; }
  if(state==='liftoff' && t > 0.6 + (SEQ.prelaunch+SEQ.ignition+SEQ.liftoff)/1000) { state='cruise'; }

  if(planet) planet.rotation.y += 0.01 * dt * 60;

  let thrust = 0;
  if(state==='prelaunch') thrust = 0.12 * easeInOutQuad(Math.min(1,(t-0.6)/(SEQ.prelaunch/1000)));
  else if(state==='ignition') thrust = 0.7 * easeOutCubic(Math.min(1,(t - (0.6 + SEQ.prelaunch/1000))/(SEQ.ignition/1000)));
  else if(state==='liftoff') thrust = 0.9 + 0.6 * easeOutCubic(Math.min(1,(t - (0.6 + (SEQ.prelaunch+SEQ.ignition)/1000))/(SEQ.liftoff/1000)));
  else if(state==='cruise') thrust = 0.7 + Math.sin(now/200) * 0.08;

  const startPos = new THREE.Vector3(0, -6, 10);
  const liftPos  = new THREE.Vector3(-6, 8, -60);
  const targetPos= new THREE.Vector3(26, 28, -520);
  let progress = 0;
  if(state==='liftoff') progress = Math.min(1, (t - (0.6 + (SEQ.prelaunch+SEQ.ignition)/1000)) / (SEQ.liftoff/1000));
  if(state==='cruise') progress = Math.min(1, (t - (0.6 + (SEQ.prelaunch+SEQ.ignition+SEQ.liftoff)/1000)) / (SEQ.cruise/1000));

  if(state==='idle' || state==='prelaunch' || state==='ignition'){
    ship.position.lerp(startPos, 0.08);
    ship.rotation.x = lerp(ship.rotation.x, -0.03 + Math.sin(now/1200)*0.01, 0.08);
    ship.rotation.y = lerp(ship.rotation.y, Math.sin(now/900)*0.01, 0.08);
  } else if(state==='liftoff'){
    const s = easeOutCubic(progress);
    ship.position.lerpVectors(startPos, liftPos, s);
    ship.rotation.x = lerp(-0.03, -0.42, s);
    ship.rotation.y = lerp(0, -0.22, s);
  } else if(state==='cruise'){
    const s = easeInOutQuad(progress);
    ship.position.lerpVectors(liftPos, targetPos, s);
    ship.rotation.x = lerp(-0.42, -0.16, s);
    ship.rotation.y = lerp(-0.22, 0.06, s);
  }

  let camZBase = (width < 768) ? 65 : 48; 
  const camStart = new THREE.Vector3(0, 10, camZBase + 8);
  const camMid   = new THREE.Vector3(0, 8, camZBase - 20); 
  const camFar   = new THREE.Vector3(28, 24, -240); 
  
  let camT = 0;
  if(state==='liftoff'){ camT = easeOutCubic(progress * 0.85); }
  else if(state==='cruise'){ camT = 0.85 + 0.15 * easeInOutQuad(progress); }
  
  let targetCamPos = new THREE.Vector3();
  if(camT < 0.5) targetCamPos.lerpVectors(camStart, camMid, camT*2);
  else targetCamPos.lerpVectors(camMid, camFar, (camT-0.5)*2);
  
  camera.position.lerp(targetCamPos, 0.12);
  const lookAt = new THREE.Vector3().copy(ship.position).add(new THREE.Vector3(0,8,-120));
  camera.lookAt(lookAt);

  const nozzleWorld = new THREE.Vector3(0, -0.4, -3.8);
  nozzleWorld.applyMatrix4(ship.matrixWorld);
  const emitRate = 22 * thrust * speedMultiplier;
  if(Math.random() < emitRate * dt * 4){ emitExhaust(nozzleWorld.x, nozzleWorld.y, nozzleWorld.z, thrust); }

  for(let i=0;i<exhaustCount;i++){
    if(exLife[i] > 0){
      exAge[i] += dt;
      if(exVel[i].initialized !== true){
        exVel[i].x = (Math.random()-0.5) * 1.4; exVel[i].y = -2.0 - Math.random()*1.8; exVel[i].z = Math.random()*2.4; exVel[i].initialized = true;
      }
      exPos[i*3] += exVel[i].x * 6 * dt * (0.6 + thrust*1.6);
      exPos[i*3+1] += exVel[i].y * 6 * dt * (0.6 + thrust*1.4);
      exPos[i*3+2] += exVel[i].z * 6 * dt * (0.6 + thrust*1.4);
      exVel[i].x *= (0.994 - dt*0.02); exVel[i].y += 0.9 * dt; exVel[i].z *= (0.994 - dt*0.02);
      exLife[i] -= dt * (0.9 + Math.random()*0.6);
      if(exLife[i] <= 0){ exPos[i*3]=10000; exLife[i]=0; exVel[i].initialized = false; }
    }
  }
  exGeo.attributes.position.needsUpdate = true; exGeo.attributes.aLife.needsUpdate = true;
  starfield.rotation.y += 0.015 * dt * 60;

  if(state==='cruise' && planet){
    planet.position.z = lerp(-800, -680, easeInOutQuad(progress));
    planet.position.y = lerp(-12, -2, easeInOutQuad(progress));
  }

  if (state === 'cruise' && progress >= 1 && !animationComplete) {
    animationComplete = true;
    triggerTransition(2500); 
  }

  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}
</script>
</body>
</html>